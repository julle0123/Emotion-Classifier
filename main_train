# -*- coding: utf-8 -*-
"""
Trainer ê¸°ë°˜ ìµœì¢… íŒŒì¸íŠœë‹ ìŠ¤í¬ë¦½íŠ¸
- ì…ë ¥(í•„ìˆ˜): /data/emotion_tagged_conversations_pred.json
  í¬ë§·: [{"id","user_input","bot_response","emotion"}]  # emotion = ì˜ì‚¬ë¼ë²¨

ì£¼ìš” ì„¸íŒ…
- ëª¨ë¸: ê¸°ë³¸ KLUE/roberta-base (ì¥ë¬¸/ë¯¸ë¬˜í•œ ë¬¸ë§¥ ê°•ì ). KcELECTRAë¡œ ë°”ê¾¸ë ¤ë©´ MODEL_NAMEë§Œ ìˆ˜ì •
- NFKC ì •ê·œí™”, MAX_LEN=224, Label Smoothing=0.05
- EarlyStopping(patience=2), best ëª¨ë¸ ìë™ ë¡œë“œ

"""
import os, json, unicodedata as ud
import numpy as np
import pandas as pd
from dataclasses import dataclass

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, f1_score

import torch
from datasets import Dataset
from transformers import (
    AutoTokenizer, AutoModelForSequenceClassification,
    TrainingArguments, Trainer, EarlyStoppingCallback, set_seed,
)

# ===== ê²½ë¡œ/ë¼ë²¨ =====
DATA_DIR = "data"
PSEUDO_JSON = os.path.join(DATA_DIR, "emotion_tagged_conversations_pred.json")
GOLDEN_JSON = os.path.join(DATA_DIR, "golden_sample_filtered.json")  # ìˆìœ¼ë©´ testìš© í‰ê°€
OUT_DIR = os.path.join(DATA_DIR, "outputs_trainer_final2")
os.makedirs(OUT_DIR, exist_ok=True)

LABELS = ['ë¶„ë…¸','ë¶ˆì•ˆ','ìŠ¬í””','í‰ì˜¨','ë‹¹í™©','ê¸°ì¨']
label2id = {k:i for i,k in enumerate(LABELS)}
id2label = {v:k for k,v in label2id.items()}

# ===== ì„¤ì • =====
SEED = 42
set_seed(SEED)
MODEL_NAME = "klue/roberta-base"   # â† í•„ìš”ì‹œ "beomi/KcELECTRA-base-v2022"
MAX_LEN = 224
LR = 2e-5
TRAIN_EPOCHS = 6          # ì˜ì‚¬ë¼ë²¨ ë…¸ì´ì¦ˆ ê³ ë ¤(5~6 ê¶Œì¥)
BATCH_TRAIN = 32
BATCH_EVAL = 64
WARMUP_RATIO = 0.05
WEIGHT_DECAY = 0.01
LABEL_SMOOTHING = 0.05
PATIENCE = 2

# ===== ë°ì´í„° ë¡œë“œ & ë¶„í•  =====
with open(PSEUDO_JSON, 'r', encoding='utf-8') as f:
    rows = json.load(f)

df = pd.DataFrame(rows)
assert {'user_input','emotion'}.issubset(df.columns), "JSON must have user_input & emotion"

def nfkc_keep(s: str) -> str: return ud.normalize('NFKC', str(s))

df = df[['user_input','emotion']].rename(columns={'user_input':'text','emotion':'label'}).copy()
df['text'] = df['text'].astype(str).map(nfkc_keep)
df = df[df['label'].isin(LABELS)].reset_index(drop=True)
df['label'] = df['label'].map(label2id)

# 90/10 stratified split
train_df, val_df = train_test_split(df, test_size=0.10, random_state=SEED, stratify=df['label'])
print(f"[Split] train={len(train_df):,} val={len(val_df):,}")

# ===== Dataset ë³€í™˜ =====
raw_train = Dataset.from_pandas(train_df.reset_index(drop=True))
raw_val   = Dataset.from_pandas(val_df.reset_index(drop=True))

# ===== Tokenizer / ì „ì²˜ë¦¬ =====
tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)

def preprocess_func(batch):
    enc = tokenizer(
        batch['text'],
        truncation=True,
        padding='max_length',
        max_length=MAX_LEN,
    )
    enc['labels'] = batch['label']
    return enc

train_ds = raw_train.map(preprocess_func, batched=True, remove_columns=raw_train.column_names)
val_ds   = raw_val.map(preprocess_func,   batched=True, remove_columns=raw_val.column_names)

# ===== ëª¨ë¸ =====
model = AutoModelForSequenceClassification.from_pretrained(
    MODEL_NAME,
    num_labels=len(LABELS),
    id2label=id2label,
    label2id=label2id,
)

# ===== í‰ê°€ì§€í‘œ =====
def compute_metrics(eval_pred):
    logits, labels = eval_pred
    preds = np.argmax(logits, axis=-1)
    return {
        'accuracy': accuracy_score(labels, preds),
        'macro_f1': f1_score(labels, preds, average='macro'),
        'weighted_f1': f1_score(labels, preds, average='weighted'),
    }

# ===== í•™ìŠµ ì¸ì =====
args = TrainingArguments(
    output_dir=OUT_DIR,
    per_device_train_batch_size=BATCH_TRAIN,
    per_device_eval_batch_size=BATCH_EVAL,
    num_train_epochs=TRAIN_EPOCHS,
    learning_rate=LR,
    warmup_ratio=WARMUP_RATIO,
    weight_decay=WEIGHT_DECAY,
    bf16=torch.cuda.is_available(),    
    logging_steps=100,
    eval_strategy='epoch',
    save_strategy='epoch',
    save_total_limit=2,
    load_best_model_at_end=True,
    metric_for_best_model='macro_f1',
    greater_is_better=True,
    label_smoothing_factor=LABEL_SMOOTHING,
    report_to='none',                 # wandb ë“± ë¯¸ì‚¬ìš©
)

# ===== Trainer (í•„ìš”ì‹œ class weights ì ìš©í•˜ë ¤ë©´ compute_loss ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥) =====
trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_ds,
    eval_dataset=val_ds,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
    callbacks=[EarlyStoppingCallback(early_stopping_patience=PATIENCE)],
)

# ===== í•™ìŠµ =====
trainer.train()

# ===== ì €ì¥ =====
best_dir = os.path.join(OUT_DIR, 'best_model')
trainer.save_model(best_dir)
tokenizer.save_pretrained(best_dir)
print(f"\n Saved best model to: {best_dir}")

# ===== (ì˜µì…˜) ê³¨ë“ ì…‹ í…ŒìŠ¤íŠ¸ =====
if os.path.exists(GOLDEN_JSON):
    with open(GOLDEN_JSON, 'r', encoding='utf-8') as f:
        gold = json.load(f)
    gdf = pd.DataFrame(gold)[['user_input','emotion']].rename(columns={'user_input':'text','emotion':'label'})
    gdf = gdf[gdf['label'].isin(LABELS)].reset_index(drop=True)
    gdf['label'] = gdf['label'].map(label2id)
    graw = Dataset.from_pandas(gdf)
    gset = graw.map(preprocess_func, batched=True, remove_columns=graw.column_names)
    eval_res = trainer.evaluate(eval_dataset=gset)
    print("\nğŸ“Š GOLDEN Test Results:")
    for k, v in eval_res.items():
        if isinstance(v, float): print(f"{k}: {v:.6f}")
        else: print(k, v)
